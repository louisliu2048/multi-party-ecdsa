#![allow(non_snake_case)]

use std::{env, fs};
use crate::protocols::multi_party_ecdsa::gg_2018::party_i::{
    verify, KeyGenBroadcastMessage1, KeyGenDecommitMessage1, Keys, LocalSignature, Parameters,
    PartyPrivate, Phase5ADecom1, Phase5Com1, SharedKeys, SignKeys,
};
use crate::utilities::mta::{MessageA, MessageB};
use std::time::Instant;
use curv::arithmetic::traits::Converter;
use curv::cryptographic_primitives::hashing::{Digest, DigestExt};
use curv::cryptographic_primitives::proofs::sigma_dlog::DLogProof;
use curv::cryptographic_primitives::secret_sharing::feldman_vss::VerifiableSS;
use curv::elliptic::curves::{secp256_k1::Secp256k1, Point, Scalar};
use paillier::*;
use sha2::Sha256;
use crate::protocols::multi_party_ecdsa::gg_2018::keygen_rounds::LocalPartySaveData;
use crate::protocols::multi_party_ecdsa::gg_2018::sign_rounds::{LocalParty, OnlineR};
use std::sync::mpsc;
use uuid::Uuid;
use std::collections::HashMap;
use secp256k1::{Message, PublicKey, SECP256K1, Signature};

#[test]
fn test_sign_2_3() {
    sign_t_n_parties(1, 3);
}

pub fn sign_t_n_parties(t: u16, n: u16) {
    if t + 2 > n {
        panic!("invalid param of t: {} - n: {}", t, n);
    }

    let message_bn = BigInt::from_bytes(b"Cobo");

    let (msg_sender, msg_receiver) = mpsc::channel();
    let (end_sender, end_receiver) = mpsc::channel();

    let mut party_round_map = HashMap::new();
    let mut y_sum = Point::zero();
    for i in 1..t + 2 {
        // read key file
        let proj_dir = env::current_dir().expect("not found path");
        let file_path = format!("benches/multi_party_ecdsa/gg18/keys{}.store",  i);
        let data = fs::read_to_string(proj_dir.join(file_path).to_str().unwrap())
            .expect("Unable to load keys, did you run keygen first? ");
        let local_data: LocalPartySaveData = serde_json::from_str(&data).unwrap();

        let uuid = Uuid::new_v4().to_string();

        let local_party = LocalParty::new(
            local_data,
            t as u16,
            i,
            uuid,
            message_bn.clone(),
            msg_sender.clone(),
            end_sender.clone(),
        );

        y_sum = local_party.data.y_sum.clone();

        let round = local_party.start().map(OnlineR::R0).unwrap();

        party_round_map.insert(i, round);
    }

    let start = Instant::now();

    let mut cnt = 0;
    for received in msg_receiver {
        if received.is_broadcast {
            for idx in 1..t+2 {
                if idx != received.from.clone() {
                    let next =  gg18_round(party_round_map.get(&idx).unwrap().clone(), received.data.clone());
                    party_round_map.insert(idx, next);
                }
            }
        } else {
            let next = gg18_round(party_round_map.get(&received.to).unwrap().clone(), received.data);
            party_round_map.insert(received.to, next);
        }

        if received.round == "round9" {
            cnt += 1;

            if cnt == t + 1 {
                break;
            }
        }
    }

    let duration = start.elapsed();
    let ms = duration.as_millis();
    println!("done! duration: {:?}ms",ms);

    cnt = 0;
    for end in end_receiver {
        check_sig(&end.r, &end.s, &message_bn.clone(), &y_sum);

        cnt += 1;
        if cnt == t + 1 {
            break;
        }
    }
}

fn gg18_round(current_round: OnlineR, msg: String) -> OnlineR {
    let mut round_ans_vec = Vec::new();
    round_ans_vec.push(msg);

    match current_round {
        OnlineR::R0(round) => {
            return round.update(&round_ans_vec).map(OnlineR::R1).unwrap();
        }
        OnlineR::R1(round) => {
            return round.update(&round_ans_vec).map(OnlineR::R2).unwrap();
        }
        OnlineR::R2(round) => {
            return round.update(&round_ans_vec).map(OnlineR::R3).unwrap();
        }
        OnlineR::R3(round) => {
            return round.update(&round_ans_vec).map(OnlineR::R4).unwrap();
        }
        OnlineR::R4(round) => {
            return round.update(&round_ans_vec).map(OnlineR::R5).unwrap();
        }
        OnlineR::R5(round) => {
            return round.update(&round_ans_vec).map(OnlineR::R6).unwrap();
        }
        OnlineR::R6(round) => {
            return round.update(&round_ans_vec).map(OnlineR::R7).unwrap();
        }
        OnlineR::R7(round) => {
            return round.update(&round_ans_vec).map(OnlineR::R8).unwrap();
        }
        OnlineR::R8(round) => {
            return round.update(&round_ans_vec).map(OnlineR::R9).unwrap();
        }
        OnlineR::R9(round) => {
            return round.update(&round_ans_vec).map(OnlineR::Finished).unwrap();
        }
        s @ OnlineR::Finished(_) | s @ OnlineR::Gone => {
            return s;
        }
    }
}

pub fn check_sig(
    r: &Scalar<Secp256k1>,
    s: &Scalar<Secp256k1>,
    msg: &BigInt,
    pk: &Point<Secp256k1>,
) {
    let raw_msg = BigInt::to_bytes(msg);
    let mut msg: Vec<u8> = Vec::new(); // padding
    msg.extend(vec![0u8; 32 - raw_msg.len()]);
    msg.extend(raw_msg.iter());

    let msg = Message::from_slice(msg.as_slice()).unwrap();
    let mut raw_pk = pk.to_bytes(false).to_vec();
    if raw_pk.len() == 64 {
        raw_pk.insert(0, 4u8);
    }
    let pk = PublicKey::from_slice(&raw_pk).unwrap();

    let mut compact: Vec<u8> = Vec::new();
    let bytes_r = &r.to_bytes().to_vec();
    compact.extend(vec![0u8; 32 - bytes_r.len()]);
    compact.extend(bytes_r.iter());

    let bytes_s = &s.to_bytes().to_vec();
    compact.extend(vec![0u8; 32 - bytes_s.len()]);
    compact.extend(bytes_s.iter());

    let secp_sig = Signature::from_compact(compact.as_slice()).unwrap();

    let is_correct = SECP256K1.verify(&msg, &secp_sig, &pk).is_ok();
    assert!(is_correct);
}
